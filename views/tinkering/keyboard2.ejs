<%include ../partials/header%>
<link rel="stylesheet" href="/gallery.css" />
<%include ../partials/navbar%>
<div class="container">
    <div class="col-lg-8 offset-lg-2 col-md-8 offset-md-2 col-sm-10 offset-sm-1 col-xs-10 offset-xs-1 extended-headers">
        <h1>Custom Keybaord Mk.II</h1>
        <h2>Hardware</h2>
        <h3>CAD & Prototyping</h3>
    
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/cad1.png" />
            <span>LibreCAD Layout</span>
        </div>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Prototype1.jpg" />
            <span>Physical Prototype</span>
        </div>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Prototype2.jpg" />
            <span>Revised Prototype</span>
        </div>
        
        <h3>Assembly</h3>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/LaserCutParts.jpg" />
            <span>Top and Bottom Plate</span>
        </div>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/TopPlateClearCoat.jpg" />
            <span>Top Plate Finished</span>
        </div>
    
        
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/TestFit1.jpg" />
            <span>Test Fit</span>
        </div>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/TestFit2.jpg" />
            <span>Test Fit</span>
        </div>
        
    
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Assembly1.jpg" />
            <span>Buttons and Joystick Glued</span>
        </div>
    
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Assembly2.jpg" />
            <span>Adding Key Switches</span>
        </div>
        <p>
            The rotary encoders turned out to be a big pain. Firstly, the holes in the top plate
            were designed to fit the shaft. It turned out that the shaft of the encoder was not
            long enough to go through both the acrylic and bamboo top plates. I ended up using a
            set of files to expand the acrylic top plate's holes to fit the rectangular footprint
            of the encoder.
        </p>
            
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Assembly3.jpg" />
            <span>Rotary Encoder</span>
        </div>
        <p>
            Next, the encoders had a little nub that prevented them from sitting flush against a
            top plate. That had to be removed with my flush cutters.
        </p>
        
        <p>
            With all components in place, I could plan out how to connect everything. Note that
            the wiring guide says that current goes into columns and comes out of rows, but that
            was just a helpful way for me to think about it. I'll explain in more detail in the
            <a href="#switch-matrix">switch matrix</a> section below.
        </p>
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/wiring_guide.png" />
            <span>Wiring Plans</span>
        </div>
        <p>
            Not shown in the plans are the connections from the Teensy to the rows and columns
            (you can see them marked with colorful dots).
        </p>
        
        <div class="figure figure-center figure-medium">
            <img class="figure-content" src="/res/portfolio/tinkering/keyboard1/Assembly4.jpg" />
            <span>Wiring Complete</span>
        </div>
        
        <h2>Software</h2>
    
        <h3 id="switch-matrix">Switch Matrix</h3>
    
        <h3>Display</h3>
    
        <h3>Encoders & Gray Code</h3>
    
        <p>
            Most rotary encoders use <a href="https://en.wikipedia.org/wiki/Gray_code">gray code</a> to
            communicate when and in which direction they have been rotated. Gray code is an ordered sequence
            of codes (usually represented as binary) where each code differs from its immediate neighbors by
            only 1 bit.
        </p>
        <p>
            StackExchange user Spehro Pefhany wrote a great explanation of
            <a href="https://electronics.stackexchange.com/a/464420">why gray code is better than binary.</a>
            Essentially, due to mechanical imperfections it is nearly impossible to change multiple bits at the
            same time. If the encoder used binary, the logic system may not be able to accommodate the "in-between"
            states when multiple bits are changing. Gray code is preferable because only one bit changes between each
            state, so no need to worry about different bits changing at different times.
        </p>
        <p>
            So gray code is awesome because it is inherently robust. The disadvantage is that programming
            a micro-controller (MCU), or reading code that other people have programmed to interpret it,
            is way more work than it ought to be. And indeed, there is a standard function that most
            people just copy/paste. Here it is:
        </p>
        
        <pre><code class="cpp">
void encoder_read(void) {
    for (int i = 0; i < NUMBER_OF_ENCODERS; i++) {
        encoder_state[i] <<= 2;
        encoder_state[i] |= (readPin(encoders_pad_a[i]) << 0) | (readPin(encoders_pad_b[i]) << 1);
        encoder_value[i] += encoder_LUT[encoder_state[i] & 0xF];
        if (encoder_value[i] >= ENCODER_RESOLUTION) {
            encoder_update_kb(i, COUNTRECLOCKWISE);
        }
        if (encoder_value[i] <= -ENCODER_RESOLUTION) { // direction is arbitrary here, but this clockwise
            encoder_update_kb(i, CLOCKWISE);
        }
        encoder_value[i] %= ENCODER_RESOLUTION;
    }
}
        </code></pre>

        <p>
            Gross. But I had to write the firmware from scratch and I wanted to really understand how the code works,
            so I had the pleasure of trying to figure out what was going on. I ended up doing some light refactoring,
            but at the end of the day, this code needs to be as fast as possible, so making it any more readable would
            probably make it less efficient. Here is what I did:
        </p>

        <pre><code class="cpp">           
void scan_encoders(){
    for(int i = 0; i < NUMBER_OF_ENCODERS; i++){
        //Prev state is still in the left-most 2 bits. Move it over 2 to make room for the next state
        last_encoder_states[i] <<= 2;

        //Read pin A and B into the 2 left-most bits where B is in the left-most bit and A is in the second-to-left-most bit
        last_encoder_states[i] |= ((read_pin(encoders_pin_a[i]) << 0) | (read_pin(encoders_pin_b[i]) << 1));

        //look up value using state table
        encoder_values[i] += enc_states[last_encoder_states[i] & 0xf];

        if(encoder_values[i] >= ENCODER_RESOLUTION){
            on_encoder(i, true);    //Encoder rotated clockwise
        }
        else if(encoder_values[i] <= -ENCODER_RESOLUTION){
            on_encoder(i, false);   //Encoder rotated counter-clockwise
        }

        encoder_values[i] %= ENCODER_RESOLUTION;
    }
}    
        </code></pre>

        <p>
            The first step to understanding this is to grasp how the states work. Each encoder has two pads (or pins,
            depending on how you think about the circuit), so the state can be stored as 2 bits (AB). However, we want to
            know when the state changes, so we need to keep track of the previous state. We're up to 4 bits total (ABAB).
            The first two bits are the previous state, and the final two are the current state. Now the first line
            makes sense:
        </p>

        <pre><code class="cpp">
//Prev state is still in the left-most 2 bits. Move it over 2 to make room for the next state
last_encoder_states[i] <<= 2;
        </code></pre>

        <p>
            But the real work in this function is done on this line:
        </p>

        <pre><code class="cpp">
//look up value using state table
encoder_values[i] += enc_states[last_encoder_states[i] & 0xf];
        </code></pre>
    
        <p>
            "enc_states" is a lookup table that translates the gray code into a
            clockwise (1), counter-clockwise (-1), or no-change (0) value. The lookup
            table is constructed using a few rules:
            <br/>
            <br/>
            Rule 1: The encoder must have been rotated counter-clockwise if...
            <ol type="a">
                <li>A has change and it is equal to B, or</li>
                <li>B has changed and it is opposite of A</li>
            </ol>
            <br/>
            Rule 2: The encoder must have been rotated clockwise if...
            <ol type="a">
                <li>A has changed and it is opposite of B, or</li>
                <li>B has changed and it is equal to A</li>
            </ol>

            These rules may be more obvious next to diagrams of A and B while the encoder is rotating.
            Remember that the encoders were designed with these rules as part of the specification.
        </p>
        <pre><code class="plaintext">
COUNTER-CLOCKWISE diagram

A
      ________      ________      ________
      |      |      |      |      |      |
      |      |      |      |      |      |
______|      |______|      |______|      |
---------------------------------------------------> time

B
   ________      ________      ________
   |      |      |      |      |      |
   |      |      |      |      |      |
___|      |______|      |______|      |___
---------------------------------------------------> time

Rule 1.a) When A changes, it is equal to B
Rule 1.b) When B changes, it is opposite of A
        </code></pre>
        <pre><code class="plaintext">
CLOCKWISE diagram

A
      ________      ________      ________
      |      |      |      |      |      |
      |      |      |      |      |      |
______|      |______|      |______|      |
---------------------------------------------------> time


B
____      ________      ________      ______
   |      |      |      |      |      |
   |      |      |      |      |      |
   |______|      |______|      |______|
---------------------------------------------------> time

Rule 2.a) When A changes, it is opposite of B
Rule 2.b) When B changes, it is equal to A
        </code></pre>
    
        <p>
            On to building the lookup table. Each index is a 4-bit integer and can be split into
            a previous state and current state (recall the ABAB encoding from before). Then all
            we have to do is figure out which pads changed from the previous state to the current,
            and using our rules we can determine if the change was a clockwise or counter-clockwise
            rotation. Here's the full table, annotated with what changed and which rule applies:
        </p>
        
        <table class="minimalistBlack">
            <thead>
                <tr>
                    <th>Previous AB</th>
                    <th>Current AB</th>
                    <th>Index</th>
                    <th>enc_states</th>
                    <th>Description</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>LL</td>
                    <td>LL</td>
                    <td>0  (00 00)</td>
                    <td>0</td>
                    <td>(no change from old state)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>LL</td>
                    <td>LH</td>
                    <td>1  (00 01)</td>
                    <td>-1</td>
                    <td>B changes to opposite of A</td>
                    <td>Rule 1.b (CCW)</td>
                </tr>
                <tr>
                    <td>LL</td>
                    <td>HL</td>
                    <td>2  (00 10)</td>
                    <td>1</td>
                    <td>A changes to opposite of B</td>
                    <td>Rule 2.a (CW)</td>
                </tr>
                <tr>
                    <td>LL</td>
                    <td>HH</td>
                    <td>3  (00 11)</td>
                    <td>0</td>
                    <td>(Both change, cannot determine)</td>
                    <td>Invalid gray code</td>
                </tr>
                <tr>
                    <td>LH</td>
                    <td>LL</td>
                    <td>4  (01 00)</td>
                    <td>1</td>
                    <td>B changes to equal A</td>
                    <td>Rule 2.b (CW)</td>
                </tr>
                <tr>
                    <td>LH</td>
                    <td>LH</td>
                    <td>5  (01 01)</td>
                    <td>0</td>
                    <td>(no change from old state)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>LH</td>
                    <td>HL</td>
                    <td>6  (01 10)</td>
                    <td>0</td>
                    <td>(Both change, cannot determine)</td>
                    <td>Invalid gray code</td>
                </tr>
                <tr>
                    <td>LH</td>
                    <td>HH</td>
                    <td>7  (01 11)</td>
                    <td>-1</td>
                    <td>A changes to equal B</td>
                    <td>Rule 1.a (CCW)</td>
                </tr>
                <tr>
                    <td>HL</td>
                    <td>LL</td>
                    <td>8  (10 00)</td>
                    <td>-1</td>
                    <td>A changes to equal B</td>
                    <td>Rule 1.a (CCW)</td>
                </tr>
                <tr>
                    <td>HL</td>
                    <td>LH</td>
                    <td>9  (10 01)</td>
                    <td>0</td>
                    <td>(Both change, cannot determine)</td>
                    <td>Invalid gray code</td>
                </tr>
                <tr>
                    <td>HL</td>
                    <td>HL</td>
                    <td>10 (10 10)</td>
                    <td>0</td>
                    <td>(no change from old state)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>HL</td>
                    <td>HH</td>
                    <td>11 (10 11)</td>
                    <td>1</td>
                    <td>B changes to equal A</td>
                    <td>Rule 2.b (CW)</td>
                </tr>
                <tr>
                    <td>HH</td>
                    <td>LL</td>
                    <td>12 (11 00)</td>
                    <td>0</td>
                    <td>(Both change, cannot determine)</td>
                    <td>Invalid gray code</td>
                </tr>
                <tr>
                    <td>HH</td>
                    <td>LH</td>
                    <td>13 (11 01)</td>
                    <td>1</td>
                    <td>A changes to opposite of B</td>
                    <td>Rule 2.a (CW)</td>
                </tr>
                <tr>
                    <td>HH</td>
                    <td>HL</td>
                    <td>14 (11 10)</td>
                    <td>-1</td>
                    <td>B changes to opposite of A</td>
                    <td>Rule 1.b (CCW)</td>
                </tr>
                <tr>
                    <td>HH</td>
                    <td>HH</td>
                    <td>15 (11 11)</td>
                    <td>0</td>
                    <td>(no change from old state)</td>
                    <td></td>
                </tr>
            </tbody>
        </table>


        <p>
            So after all of that, the rest is easy. We now know the direction of rotation,
            so we can call some other function accordingly.
        </p>

        <pre><code class="cpp">
//look up value using state table
encoder_values[i] += enc_states[last_encoder_states[i] & 0xf];

if(encoder_values[i] >= ENCODER_RESOLUTION){
    on_encoder(i, true);    //Encoder rotated clockwise
}
else if(encoder_values[i] <= -ENCODER_RESOLUTION){
    on_encoder(i, false);   //Encoder rotated counter-clockwise
}

encoder_values[i] %= ENCODER_RESOLUTION;
        </code></pre>
        
        <p>
            The ENCODER_RESOLUTION is used to slow down and sort of "smooth" the result.
            It is usually set to 2 or 4.
            If we read one clockwise rotation, did it really rotate or did the encoder
            just get nudged a little bit? If we read four rotations, we can be reasonably
            sure that the encoder did actually rotate.
             
        </p>
    </div>
</div>
<%include ../partials/footer%>